<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hktkdy.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="分享是一种快乐">
<meta property="og:type" content="website">
<meta property="og:title" content="海阔天空的云">
<meta property="og:url" content="http://hktkdy.com/page/6/index.html">
<meta property="og:site_name" content="海阔天空的云">
<meta property="og:description" content="分享是一种快乐">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhangolve">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hktkdy.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>海阔天空的云</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="海阔天空的云" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">海阔天空的云</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我们在自己的世界里独自狂欢</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/12/01/201812/oauth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/01/201812/oauth/" class="post-title-link" itemprop="url">闲话OAUTH</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-01 09:24:49" itemprop="dateCreated datePublished" datetime="2018-12-01T09:24:49+08:00">2018-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/12/01/201812/oauth/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/12/01/201812/oauth/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前面"><a href="#前面" class="headerlink" title="前面"></a>前面</h1><p>作为一面全栈工程师(偏重前端)，对待老大交代下来的后端任务也是需要认真完成的。前段时间，有个工作，要通过淘宝的OAUTH进行授权，进而获取到access_token，通过access_token来作为授权码，进行所有需要登录权限的API访问，这些API 包括但不限于用户，商品，交易，评价，物流等API.</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>在这里也无须去科普OAUTH2.0协议到底是什么了,感兴趣的可以自己去查wiki.</p>
<p>我来说的仍然是我自己的理解,所以OAUTH到底做了什么呢?它是一直验证机制,这个机制实现了两步验证,仍然以淘宝API获取access_token为例,淘宝认为开发者访问用户的信息,是以应用为单位的,每一个应用需要一个app_id,app_secret,我们是先要通过app_id 来置换到一个叫做code的字段,这个字段只是作为一个过渡,我们能够通过code值,再调取一个api,才能够最终获取到access_token.</p>
<p>拿实际例子来说,</p>
<p><strong>、授权操作步骤</strong></p>
<p>    此处以正式环境获取acccess_token为例说明，如果是沙箱环境测试，需将请求入口地址等相关数据换成沙箱对应入口地址，操作流程则同正式环境一致。<br>    实际进行授权操作时，测试的数据 client_id、client_secret、redirect_uri 均需要根据自己创建的应用实际数据给予替换，不能拿示例中给出的值直接进行测试，以免影响实际测试效果。下图为Server-side flow 授权方式流程图，以下按流程图逐步说明。<br><img src="http://upload-images.jianshu.io/upload_images/48180-daa679ca3643bb11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="授权步骤"></p>
<p><strong>1）拼接授权url</strong><br>拼接用户授权需访问url ，示例及参数说明如下：<br><a target="_blank" rel="noopener" href="https://oauth.taobao.com/authorize?response_type=code&client_id=23075594&redirect_uri=http://www.oauth.net/2/&state=1212&view=web">https://oauth.taobao.com/authorize?response_type=code&amp;client_id=23075594&amp;redirect_uri=http://www.oauth.net/2/&amp;state=1212&amp;view=web</a></p>
<table>
<thead>
<tr>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>名称</td>
</tr>
<tr>
<td>client_id</td>
</tr>
<tr>
<td>response_type</td>
</tr>
<tr>
<td>redirect_uri</td>
</tr>
<tr>
<td>state</td>
</tr>
<tr>
<td>view</td>
</tr>
</tbody></table>
<p><strong>2）引导用户登录授权</strong><br>引导用户通过浏览器访问以上授权url，将弹出如下登录页面。用户输入账号、密码点“登录”按钮，即可进入授权页面。<br><img src="http://upload-images.jianshu.io/upload_images/48180-bdff42029bd50cbc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="授权"></p>
<p><strong>3）获取code</strong><br>上图页面，若用户点“授权”按钮后，TOP会将授权码code 返回到了回调地址上，应用可以获取并使用该code去换取access_token；<br>若用户未点授权而是点了“取消”按钮，则返回如下结果，其中error为错误码，error_description为错误描述。分别如下图所示：<img src="http://upload-images.jianshu.io/upload_images/48180-784ed87b1c50d9ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误"></p>
<p><strong>4）换取access_token</strong></p>
<p>方式1（推荐）：</p>
<p>通过taobao.top.auth.token.create api接口获取access_token（授权令牌）。api服务地址参考<a target="_blank" rel="noopener" href="http://open.taobao.com/docs/doc.htm?spm=a219a.7386781.3.7.tO1lHe&docType=1&articleId=101617&treeId=1">http://open.taobao.com/docs/doc.htm?docType=1&articleId=101617&treeId=1</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说起来,我最早使用OAUTH进行登录或者授权操作,还是早些年在用微博的时候,如果OAUTH的应用已经非常广泛了,了解它对我们,无论前端开发还是后端开发都有很多好处.</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="http://open.taobao.com/doc.htm?docId=102635&docType=1">http://open.taobao.com/doc.htm?docId=102635&amp;docType=1</a></p>
<p><a target="_blank" rel="noopener" href="http://open.taobao.com/api.htm?docId=285&docType=2">http://open.taobao.com/api.htm?docId=285&amp;docType=2</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/09/01/201809/webpack-and-autoprefix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/01/201809/webpack-and-autoprefix/" class="post-title-link" itemprop="url">在webpack项目中配置postcss，实现autoprefix</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-01 09:24:49" itemprop="dateCreated datePublished" datetime="2018-09-01T09:24:49+08:00">2018-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/09/01/201809/webpack-and-autoprefix/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/09/01/201809/webpack-and-autoprefix/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>##１希望能够让开发者写代码更轻松</p>
<p>以往没有引入postcss autoprefixer之前，我们为了css相关特性能够在各个浏览器上的兼容，引入了scss，利用它的mixins来实现prefix。但是每一个mixin　都有一个自己的语法。</p>
<p>比如以往，如果我们我们想要写一条</p>
<pre><code>div &#123;
    display: flex;
    align-items: center;
    justify-content: center;
&#125;
</code></pre>
<p>为了各个相对早期浏览器的prefix，我们需要mixin，然后这样写</p>
<pre><code>import &#39;common/flexbox&#39;;

div &#123;
    @include flexbox;
    @flex(1);
    @justify-content(center);
&#125;
</code></pre>
<p>然后按照这样的约定，来加上需要的prefix。</p>
<p>这当然是一个方法，但是对于开发者来讲，实际上增加了一些学习成本，而且相当于将标准放到了一边，去使用另外一套标准。</p>
<p>我们之前的mixin，由于已经有好几年的历史。当时为了兼容市面上那些还有很大市场份额的浏览器，prefix写的很全。比如下面这个mixin　flexbox到代码:</p>
<pre><code>@mixin flexbox &#123;
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
&#125;
</code></pre>
<p>为了写这篇博客，我又确认了一下，那个mixin flexbox的开源库来自于2013年，距离现在已经五年了,五年的时间，淘汰了很多过时的浏览器，五年前可能需要兼容到ie8，现在移动端开发甚至完全可以无需理睬IE的存在，所以这样的一套prefix就显得有些过时了。那位说了，我更新我的mixin不就好了，比如在2018年做移动端开发，也许我只需要将上面的代码改写成:</p>
<pre><code>@mixin flexbox &#123;
    display: -webkit-flex;
    display: flex;
&#125;
</code></pre>
<p>但是我们也许需要想地更远一些，也许再过两年，我们甚至不需要对-webkit-的支持了。那时候，难道我们又要改一遍这个mixin吗？</p>
<p>postcss解决了这样一个痛点，可以直接书写标准的css（现在是css3，但是过几年也可能就是css4了），我们有了这样的工具，再指定一个浏览器兼容表，就能够实现自动prefix，而这相比于sass&#x2F;scss　mixin的方式，维护起来更加简单，应该是一个很好的实践。</p>
<h2 id="２对用户更友好"><a href="#２对用户更友好" class="headerlink" title="２对用户更友好"></a>２对用户更友好</h2><p>这当然也是显而易见的，以前我们可能为了兼容更多浏览器，而写更多的prefix，可是随着时间的推移，很多prefix完全并不需要。我们通过postcss来处理，简单明了，缩小了生成的css文件的体积，最后反映到用户那里，会快上一丢丢！</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1 安装postcss-loader ,postcss-preset-env</p>
<pre><code>yarn add -D postcss-loader  postcss-preset-env
</code></pre>
<p>安装postcss-preset-env，无需再安装autoprefixer，由于postcss-preset-env已经内置了相关功能。</p>
<p>２　添加.browserlistrc　文件到项目根目录</p>
<blockquote>
<p>1% in CN<br>android &gt;&#x3D; 4.4<br>ios &gt;&#x3D; 8<br>not ie &lt;&#x3D; 11</p>
</blockquote>
<p>这个需要根据项目的世纪情况来自由选择，我是考虑我们的项目是移动端项目，且确实有用户在用Android４.4　或者ios８，但是再很难看到低于这些版本之下的系统了。</p>
<p>３配置postcss.config.js</p>
<pre><code>module.exports = &#123;
  loader: &#39;postcss-loader&#39;,  
  plugins: &#123;
      &#39;postcss-preset-env&#39;: &#123;&#125;,
    &#125;
&#125;
</code></pre>
<p>4　配置webpack.config.js</p>
<pre><code>&#123;
test: /\.scss$/,
use:[ 
    MiniCssExtractPlugin.loader,
    &#123;
        loader: &#39;css-loader&#39;,
            options: &#123;
                root: &#39;static&#39;,
                minimize: true,
                importLoaders: 1
            &#125;
    &#125;,
    &#39;postcss-loader&#39;,
    &#39;sass-loader&#39;,
]
&#125;,
&#123;
test: /\.css$/,
use: [
    MiniCssExtractPlugin.loader,
    &#123;
        loader: &#39;css-loader&#39;,
            options: &#123;
                root: &#39;static&#39;,
                minimize: true,
                importLoaders: 1
            &#125;
    &#125;,
    &#39;postcss-loader&#39;
]
&#125;
</code></pre>
<p>由于我们的项目中使用了scss，因此需要sass-loader。这里需要注意各个loader的顺序，一开始我的顺序是MiniCssExtractPlugin.loader,css-loader，sass-loader，　postcss-loader，结果发现并没有能够autoprefix，原因是如果想让postcss-loader认识并且处理，需要先用sass-loader进行处理，转化成postcss-loader可以认识的代码。</p>
<p>另外需要注意的是，我们这里还在使用css-loader v0.28，目前已经有了v1.0，版本改动很大，以至于我们暂时不能升级。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/08/09/201808/babel-and-polifill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/201808/babel-and-polifill/" class="post-title-link" itemprop="url">babel 与 polyfill两三事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 09:24:49" itemprop="dateCreated datePublished" datetime="2018-08-09T09:24:49+08:00">2018-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/08/09/201808/babel-and-polifill/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/08/09/201808/babel-and-polifill/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>熟悉前端开发的朋友，应该对 <code>Babel</code>这个项目并不陌生，早在两年多以前，阮一峰大大就已经写过文章<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/babel.html">《Babel 入门教程》</a> 对他进行了介绍，那个时候，其实<code>Babel</code>应该已经算得上是网红开源前端库了。这两年，<code>Babel</code>其实也一直在发展，我这里想说的是我看到的<code>Babel</code>的成长</p>
<h1 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel-preset-env"></a>babel-preset-env</h1><p>首先是<code>babel-preset-env</code>，详细的介绍文档在这里：<a target="_blank" rel="noopener" href="https://www.babeljs.cn/docs/plugins/preset-env/">https://www.babeljs.cn/docs/plugins/preset-env/</a></p>
<p>我也并不会去介绍怎么去用这个，只是想谈谈自己的体会。我记得刚开始使用babel的时候，的确有时候会用上一些stage-2,stage-3 的特性，那时候还为了了解这些所谓的stage去看了ECMASCRIPT 新版本发布的<a target="_blank" rel="noopener" href="https://github.com/tc39/proposals">流程</a>，觉得也很有意思。但是虽然有意思，但是配置起来却的确繁琐，有时候，你的确需要为了配置这样一个<code>Babel</code>看好多相关文档，这无疑算是一个痛点了。现在好了，就如同文档里面所提到的：</p>
<blockquote>
<p>在没有任何配置选项的情况下，babel-preset-env 与 babel-preset-latest（或者babel-preset-es2015，babel-preset-es2016和babel-preset-es2017一起）的行为完全相同。</p>
</blockquote>
<h1 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h1><h2 id="为什么你这么大"><a href="#为什么你这么大" class="headerlink" title="为什么你这么大"></a>为什么你这么大</h2><p>我们都知道，<code>Babel</code>为了存心让我们配置起来更困难，故意将他的功能分拆成了两部分，其一是语法上的转化，这个默认情况下他自会帮我们处理。而另外一部分，就是新API的polyfill，需要我们引入<code>babel-polyfill</code>来完成。当然，我前面说，<code>Babel</code>是存心折腾开发者的确是开玩笑的，毕竟并不是所有的时候我们都需要polyfill的。这有点像是React项目也有两个核心包,<code>React</code>和<code>ReactDOM</code>类似。</p>
<pre><code>    import React from &#39;react&#39;;  
    import ReactDOM from &#39;react-dom&#39;;
</code></pre>
<p> babel-polyfill是好东西，能够将新API作用在老的浏览器上，但是我们要注意不要滥用。比如我们随便在百度上搜索一篇文章，讲解如何使用 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/princesong/p/6728250.html">babel-polyfill的引用和使用</a>,往往都会看到有这样的描述：</p>
<pre><code>module.exports = &#123;entry: [&quot;babel-polyfill&quot;, &quot;./app/js&quot;]&#125;;
</code></pre>
<p>这样做，从功能实现上来看当然是没有错的。但是，如果我们原来的入口是</p>
<pre><code>module.exports = &#123;entry: [&quot;./app/js&quot;]&#125;;
</code></pre>
<p>那么很容易就能够发现由于入口处增加了<code>babel-polyfill</code>，导致webpack在处理之后，最终的到的入口核心js文件比原来增加了有100kb左右。对于这个问题，也已经有<a target="_blank" rel="noopener" href="https://github.com/babel/babel-loader/issues/163">issue</a>,不过很奇怪这位网友把issue提到了babel-loader这个项目下。</p>
<p>然后针对这个问题，有老外网友介绍到了<code>transform-runtime</code>等。但是经过我的测试，这也并不是一个很好的实践。</p>
<h2 id="动态识别"><a href="#动态识别" class="headerlink" title="动态识别"></a>动态识别</h2><p>为了polyfill 这件事情，其实是有两种思路可循的。第一个思路是根据浏览器缺失哪些特性来补全哪些特性，这个思路的代表是  <a target="_blank" rel="noopener" href="https://polyfill.io/v2/docs/">polyfill-service</a>,这个<a target="_blank" rel="noopener" href="https://github.com/Financial-Times/polyfill-service">项目</a> 。它能够根据浏览器的UA来判断当前浏览器缺失哪些特性，进而进行补强。但是经过我的调研，这个项目在天朝可能还存在水土不服的问题，一个很明显的事实是将安卓微信内置的QQ浏览器X5交给这个库来处理，它会认为当前的浏览器是safari，原因大概是因为UA上有safari这个字段。考虑到我们天朝还有类似微信这样很怪异的UA，我认为并不适合在当前这个时间来对此进行实践。(在这里多说两句，polyfill-service这个库和另外一个知名项目fastclick同属于英国金融时报，而最近我发现fastclick在现代浏览器上也有一些tricky的地方，在他们的issue区有能够找到一些吐槽，然而，这个库已经两年多没有人维护了)</p>
<p>把polyfill-service仍在一边，我们接下来说另一个思路。能不能根据我使用了多少新API，来决定我引入多少polyfill的内容呢？比如我只在我的项目中使用了ES6的<code>set</code>，没有使用其他新API。那么我引入polyfill的时候，能不能只引入set的polyfill呢？答案当然是可以的，这就是babel-7的新特性，没错，由于当前稳定版是babel-6，因此这个特性还处在测试阶段。但是根据我自己的测试，表现很多。</p>
<p>不过有趣的是，虽然还只是Beta版，Babel却将之写入了正式版的文档当中，结果当时我为了测试这个新特性，都已经测试到怀疑人生了。文档戳<a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-preset-env/#usebuiltins">这里</a>,感兴趣的同学可以去看看。总之，实际上只是对babel增加一项配置。</p>
<pre><code>      &quot;useBuiltIns&quot;: &quot;usage&quot;
</code></pre>
<p>不过由于涉及到升级<code>Babel</code>，当时我在测试的时候，还是有些不顺的。但是一旦迁移成功，应用上<code>useBuiltIns</code>的这项配置，的确能够让polyfill的体积大幅度减小。</p>
<h1 id="browserlist"><a href="#browserlist" class="headerlink" title="browserlist"></a>browserlist</h1><p>前面的动态polyfill，的确可以让webpack生成的js文件体积更小，但是能不能再小一些呢？毕竟我们前端开发的目的就是极致的用户体验，当然可以。这个时候browserlist能够帮到我们。</p>
<p>关于这个话题，网路上相关的文章非常多，我就不再多谈了。</p>
<p>感兴趣的同学，可以看看<code>ant-design</code>项目中使用的browserlist。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ant-design/antd-tools/blob/master/lib/getBabelCommonConfig.js">https://github.com/ant-design/antd-tools/blob/master/lib/getBabelCommonConfig.js</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/08/07/201808/react-7-better-ec-index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/07/201808/react-7-better-ec-index/" class="post-title-link" itemprop="url">React开发实践7--首页优化的过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-07 09:24:49" itemprop="dateCreated datePublished" datetime="2018-08-07T09:24:49+08:00">2018-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/08/07/201808/react-7-better-ec-index/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/08/07/201808/react-7-better-ec-index/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>需要说明一点是，关于比较常规的React性能优化，可以看这篇文章：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzNjcwNzA2Mw==&mid=2247485902&idx=1&sn=952e0db3bc0f36b7cd4db71b17914daa&chksm=e8d28456dfa50d407e52c935cb7518cf76f1179a8bcbbac760f1685f88fd8d809ca84f5d9c3f&mpshare=1&scene=1&srcid=0720NL5okWr9xzIeEpbQmWyZ#rd">React 16 加载性能优化指南</a>，我要聊到是一些非常规，与实际开发密切相关的坑，但也正是因为这是我个人遇到的个案，或者并不构成普遍意义。</p>
<p>我前面一篇<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/db42bb62f69a">《React开发实践5–详细说说滚动记忆》</a>  其实跟React关系不大，只是因为做React的项目遇到了问题，也就顺手写下来了。最早遇到这个问题，的确第一反映是React这个库的锅，但是稍稍理性的想一想也知道，React的本质也是JS啊，于是很快就将注意力转移了。</p>
<p>说回头来，上一篇文章说到的那个业务需求，在React-router的官方文档里专门有一节在讲，也就是<a target="_blank" rel="noopener" href="https://reacttraining.com/web/guides/scroll-restoration">Scroll Restoration</a>。这里也说到了我在上一篇结尾列出来的那个文档：<a target="_blank" rel="noopener" href="https://majido.github.io/scroll-restoration-proposal/history-based-api.html#usage">scrollRestoration</a></p>
<p>如此说来，我现在资料颇多了。有了前面的铺垫，我想我也就不用再废话了。</p>
<h1 id="CMS-这个坑"><a href="#CMS-这个坑" class="headerlink" title="CMS 这个坑"></a>CMS 这个坑</h1><p>首先我引入了一个库<code>react-router-scroll-4</code>，眼尖的朋友看出来了为什么还要带个<code>4</code>呢，这是因为原本的库是<code>react-router-scroll</code>,因为这个库不支持react-router v4，因此有开发者又fork出来一个能够支持react-router v4的分支，我用的也就是这一个了。我看过他的源码，核心思想其实就像上面提到的react-router官方文档所介绍的一样，通过session-storage 来处理。</p>
<p>之后，我开始对商品列表页和APP首页进行改造。商品列表页改造地非常简单，无非是对组件进行一次包裹。但是APP首页的改造却遇到了麻烦。同样是对该组件进行包裹，结果现象却是无法实现滚动记忆。这让我好生无奈。这又是为什么呢？我首先想到了是不是这个<code>react-router-scroll-4</code>支持不够好，毕竟这是一个连github项目库都没有的npm包，顺着这个思路，我去看了这个库的源码，又通过打印log的方式去debug，发现了问题所在：原来这个库对<code> dangerouslySetInnerHTML</code>这种注入HTML的方式没有进行处理，这里面的关键点在于生命周期，此处我并不想多讲，但最终导致无法实现滚动记忆。而我们之所以要在项目中使用<code> dangerouslySetInnerHTML</code>,也是因为项目中有用到CMS的模块，历史遗留问题，一时无法解决。</p>
<p>但是你知道的，虽然我后来通过修改这个第三方库<code>react-router-scroll-4</code>，最终实现了首页的滚动记忆，但是前面我也提到了由于使用了CMS系统，造成首页的几乎所有点击都是普通的a标签href的跳转，即这样的交互将原本的React app的优势：独立的路由体系打散了。事实证明，在性能上也造成很大问题。</p>
<p>为了更好地说明问题，举个例子。如果是在同一个路由体系下，从首页&#x2F;切换到 &#x2F;abc，这个过程，只会去加载abc路由所需要的资源。但是如果脱离了这个路由体系，而是通过普通的a标签href跳转，进入&#x2F;abc的时候，相当于又重新进入一遍app，这个时候原本一些bundle的资源又会被重新加载一边，虽然这些资源可能被浏览器缓存了起来，但是缓存好了和根本不需要又是两回事，对不对。</p>
<p>所以，如果能够尽量在进入一个React app之后，尽量不再脱离这个app，也就是一直React-router的方式进行跳转，用我前面文章提到过的说法，就是假跳转，其实是能够有很好的优势的。</p>
<p>原来有一个CMS，我会调用一个接口，返回一个HTML页面内容。如果能够将HTML转成REACT组件，这样是不是更好呢？我后来找到了<code>html-react-parser</code>这个库，其实还有另外一个库，不过另外一个库有一些问题，比如图片的url上面如果有大写字母会转成小写字母，造成图片加载失败。</p>
<p>这个库很好地解决了我的问题。接下来，我做了如下改动，一切都水到渠成。</p>
<ul>
<li><p>在第一次进入首页的时候，将首页内容(cms html)放置到React state中进行储存，在下次回到首页时，无须重复调用获取首页内容接口，即可快速获取首页内容，达到尽快地相应</p>
</li>
<li><p>将原本html上面的a标签上的click事件进行劫持，根据情况，将原来的a跳转改为react-router 的history.push()，使之不脱离这个app。由于这里没有脱离app，则当接下来用户点击返回回到首页时，还是会按照react-router的方式去返回，则次过程也不会脱离app了。</p>
</li>
</ul>
<p>这里有个小tips,如果我们获取e.target.href的话，我们会发现即便是我们原本写的a标签是这样的</p>
<p><a href="/product/1">one product</a></p>
<p>最后得到的 e.target.href也会自动添加上网址。可是我们知道history.push()只认相对路径，因此e.target.href并不能满足我们的需求，而通过获取a标签上的href属性，也就是getAttribute(‘href’),能够保留a标签上的href属性值，而这个值，正是我们所需要的。</p>
<h1 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h1><p>React应用还是应该干净一些，避免使用<code> dangerouslySetInnerHTML</code>，使用它会有很多tricky的事情发生，比如在componentDidMount的时候，dom上某个元素还处在undefind的状态，原因很可能是因为这个元素是由<code> dangerouslySetInnerHTML</code>产生的，而他往dom里面添加节点是在componentDidMount之后。</p>
<p>我还是不很确定，通过history api完成跳转的，滚动记忆的情况。</p>
<p>react-router的假跳转，其核心当然还是利用了history api</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/05/31/201805/focus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/31/201805/focus/" class="post-title-link" itemprop="url">focus 事件的监听</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-31 18:24:49" itemprop="dateCreated datePublished" datetime="2018-05-31T18:24:49+08:00">2018-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/05/31/201805/focus/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/05/31/201805/focus/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://7ktu2f.com1.z0.glb.clouddn.com/javascript.png"></p>
<hr>
<p>我在上一篇 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6392732dc7ed">薛定谔的导航栏</a>里面，关于代码的部分，用到了下面的语法：</p>
<p><code>document.addEventListener(&#39;focus&#39;, this.IosFocusHandler, true);</code></p>
<p>有同学可能会问了，为什么我们一般都默认capture:false，怎么这里监听focus事件的时候，就改成了捕获模式呢？</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus">MDN上面</a>对这一块已经说的很清楚了，因为focus事件是不支持冒泡的。但是虽然不能冒泡，但是一个事件三个阶段（捕获，处理中，冒泡），还要前两个阶段呢！所以，当我们改为捕获模式的时候，就能够在捕获阶段，拿到focus事件是否触发的消息了。</p>
<p>顺便提一句，与focus事件很像，focusin事件支持冒泡，所以按道理来说，如果我们想要在document上面监听是否有focus的动作，其实是可以使用focusin事件的，也无需再加capture:true ,但是从caniuse.com 可以知道firefox浏览器，直到17年出的firefox52才终于支持上focusin事件。</p>
<p>所以，就有了这个SO的问答： <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24809835/focusin-and-focusout-methods-not-working-in-firefox">Focusin and focusout methods not working in firefox</a></p>
<p>如果想想在firefox浏览器下有好的表现，还是应该用</p>
<p><code>document.addEventListener(&#39;focus&#39;, this.IosFocusHandler, true);</code></p>
<p>focus事件加上capture:true 的写法的。</p>
<p>类似地，blur事件和focusout事件的区别也是冒不冒泡的区别。那么问题来了，为什么focus事件不直接支持冒泡，再去掉一个重复的focusin事件呢？</p>
<p>我只能试图从focus和blur的语义上来理解了。毕竟，规范这东西，都是人规定的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/05/31/201805/react-practice-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/31/201805/react-practice-5/" class="post-title-link" itemprop="url">React开发实践--5React-router 的 updateBlocker是个什么东东</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-31 09:24:49" itemprop="dateCreated datePublished" datetime="2018-05-31T09:24:49+08:00">2018-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/05/31/201805/react-practice-5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/05/31/201805/react-practice-5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://7ktu2f.com1.z0.glb.clouddn.com/react.png"></p>
<hr>
<p>昨天在阅读<a target="_blank" rel="noopener" href="https://reacttraining.com/react-router/web/guides/dealing-with-update-blocking">react-router</a>的官方文档的时候，发现了以前没有注意到的一个东东。<code>&lt;UpdateBlocker&gt;</code></p>
<p>当时由于在试图解决一个问题: 路由切换的时候，某一个公用组件又重新didmount,即进入下一个生命周期，因而也没有好好地阅读文档，误以为这个<code>&lt;UpdateBlocker&gt;</code>的作用是能够阻止组件进入下一个生命周期。</p>
<p>后来几经测试，也没有得到满意的结果。后来仔细阅读文档，才发现与我之前的理解有很大差别。</p>
<p><code>React-router</code>文档里面提到的这个<code>&lt;UpdateBlocker&gt;</code>，实际上是只是告诉你<strong>结合React能够实现怎样的功能</strong>  。</p>
<p>我们知道有些时候，我们并不想让组件发生更新，或者根据实际情况有选择地进行更新。这样也能够最大限度地保证WEB APP的性能。而这个<code>&lt;UpdateBlocker&gt;</code>的作用正在于此。</p>
<p>这时候，其实还是要说回到<code>React</code> 的官方文档，从<a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactpurecomponent">reactpurecomponent</a>这一章节可以看出来，</p>
<blockquote>
<p><code>React.PureComponent</code> is similar to <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a>. The difference between them is that <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a> doesn’t implement <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>, but <code>React.PureComponent</code> implements it with a shallow prop and state comparison.</p>
</blockquote>
<p>就是说<code>React.PureComponent</code>内部已经实现了 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>方法，我们可以拿来就用。而不用像使用 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a>那样，如果为了实现一个同样的<strong>判断组件是否需更新</strong>的功能，手动写这样一个方法。</p>
<p>P.S 渣英语理解错了，还以为<code>React.PureComponent</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/05/30/201805/footer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/30/201805/footer/" class="post-title-link" itemprop="url">薛定谔的导航栏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-30 18:24:49" itemprop="dateCreated datePublished" datetime="2018-05-30T18:24:49+08:00">2018-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/05/30/201805/footer/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/05/30/201805/footer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://7ktu2f.com1.z0.glb.clouddn.com/javascript.png"></p>
<hr>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>自从在本单位工作之后，大部分时候做的都是移动开发。因此，也就不可避免地会遇到很多移动开发的坑。这些坑来源于真实的业务场景，因此，简单总结一下。</p>
<p>第一个坑是关于导航栏的，我们知道市面上的大部分国产APP，它的iOS版本和Android版本，在UI设计上几乎都没有区别，我们做的APP也是如此。因此，也是会在APP的底部有一个导航栏。</p>
<p>这个时候，有意思的事情就出现了。如果是H5页面的话，通常情况下，这个底部导航栏都是通过fixed定位来实现的。而由于移动终端虚拟键盘的作用，Android和iOS对此的反应又并不相同，因此，就出现了这个坑。</p>
<p>我看了很多APP，比如美团，微信，孩子王等APP，当光标聚集到输入框上面的时候，往往会有一个动画，然后将这个搜索页全屏处理。且不论这些APP是否是内嵌H5的，但这样的交互，如果在H5上面也如是一样，就能避免上面提到的由于fixed定位产生的坑。</p>
<h1 id="这个坑的详细表现"><a href="#这个坑的详细表现" class="headerlink" title="这个坑的详细表现"></a>这个坑的详细表现</h1><p>在iOS上面的表现：</p>
<blockquote>
<p>软键盘唤起后，页面的 fixed 元素将失效（即无法浮动，也可以理解为变成了 absolute 定位），所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。（ 来自<a target="_blank" rel="noopener" href="http://efe.baidu.com/blog/mobile-fixed-layout/">Web移动端Fixed布局的解决方案
</a> ）</p>
</blockquote>
<p>而在Android上面的表现是:</p>
<p> 软键盘唤起后，页面的 fixed 元素并没有失效，但是视窗的高度将重新被计算。(原来的视窗高度-虚拟键盘的高度)</p>
<p>所以，如果我们仍然要把底部导航栏和<input/>元素放在一个页面上，就需要着手进行改造。不然，就非常影响用户体验。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a target="_blank" rel="noopener" href="http://efe.baidu.com/blog/mobile-fixed-layout/">Web移动端Fixed布局的解决方案
</a> 提到的当然是一种解决方案，但是，我试着总是不能符合我的要求。</p>
<p>这就说会到我这篇文的题目《薛定谔的导航栏》，我的想法是这样的：如果弹出了虚拟键盘，则将导航栏的样式设置为<code> display:none</code>，反之，如果隐藏了虚拟键盘，则将导航栏的样式设置为<code>display:block; position:fixed</code>。所以，一个小白，如果看到了弹出虚拟键盘的页面，你问他，现在到底页面上存在不存在导航栏呢？</p>
<p>假如他回答存在，你把这个虚拟键盘隐藏掉，结果当然是有的。可是当时有没有呢？并没有吧。</p>
<p>加入他回答不存在，你把这个虚拟键盘隐藏点，结果却是有的，很明显又和实际看到的不一样了。</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>所以接下来和核心问题，就是如何在iOS上和Android上去检测虚拟键盘的弹出和隐藏了。</p>
<p>下面进入直接贴代码说明问题环节，这里要说明一下，由于我使用了React框架，因此，实际上，我下面写的代码都是JSX文件的一部分</p>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><pre><code>addIosKeyboardHandler = () =&gt; &#123;  // IOS上，弹出输入框后，同样隐藏底部导航。
    document.addEventListener(&#39;focus&#39;, this.IosFocusHandler, true);
    document.addEventListener(&#39;focusout&#39;, this.focusoutHandler, true);
&#125;

removeKeyboardHandler = () =&gt; &#123;
    document.removeEventListener(&#39;focus&#39;, this.IosFocusHandler, true);
    document.removeEventListener(&#39;focusout&#39;, this.focusoutHandler, true);
&#125;

IosFocusHandler = () =&gt; &#123;
    if (document.activeElement.tagName === &#39;INPUT&#39; || document.activeElement.tagName === &#39;TEXTAREA&#39;) &#123;
        window.scrollTo(0, 0);
        const footer = document.getElementById(&#39;footer&#39;);
        footer.classList.remove(&#39;fixed&#39;);
        footer.classList.add(&#39;hidden&#39;);
        window.setTimeout(() =&gt; &#123;
            document.activeElement.scrollIntoViewIfNeeded();
        &#125;, 100);
    &#125;
&#125;
focusoutHandler =() =&gt; &#123;
    window.scrollTo(0, 0);
    const footer = document.getElementById(&#39;footer&#39;);
    footer.classList.add(&#39;fixed&#39;);
    footer.classList.remove(&#39;hidden&#39;);
&#125;
</code></pre>
<p>这里有几个点需要注意：</p>
<ul>
<li>focus事件需要通过捕获(capture: true)的形式才能触发，在document上面的监听</li>
<li>focusout要比blur事件在描述虚拟键盘隐藏这件事情上更加准确，blur事件不会冒泡</li>
<li>当弹出输入法准备敲击时，先将页面滚动到顶部</li>
</ul>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>Android 上和IOS上又有一些不同，主要的不同点在于：当弹出虚拟键盘后，通过点击返回键，隐藏掉虚拟键盘，这个时候，如果我们对此不做任何处理的话，那么光标还是会在输入框里面，换句话说，此时对于输入框俩说，并没有发生blur事件，因为很显然，光标还在输入框里面。</p>
<p>因此还是根据Android上的表现来做判断，既然弹出虚拟键盘会让视窗的高度变小，而收起虚拟键盘又会让视窗的高度变大，那么我们就从这里着手。</p>
<pre><code>addAndroidKeyboardHandler = () =&gt; &#123;
    this.maxHeight = document.documentElement.clientHeight;
    window.addEventListener(&#39;resize&#39;, this.AndroidKeyboardHandler.bind(this, this.maxHeight));
    document.addEventListener(&#39;focusout&#39;, this.focusoutHandler, true);
&#125;

removeAndroidKeyboardHandler = () =&gt; &#123;
    window.removeEventListener(&#39;resize&#39;, this.AndroidKeyboardHandler.bind(this, this.maxHeight));
    document.removeEventListener(&#39;focusout&#39;, this.focusoutHandler, true);
&#125;

AndroidKeyboardHandler = maxHeight =&gt; &#123; // 解决 Android 弹出输入框时，底部导航一同浮起的问题。隐藏底部导航
    const presentHeight = window.innerHeight;
    const footer = document.getElementById(&#39;footer&#39;);
    if (document.activeElement.tagName === &#39;INPUT&#39; || document.activeElement.tagName === &#39;TEXTAREA&#39;) &#123;
        if (presentHeight &lt; maxHeight) &#123; // 隐藏底部导航
            footer.classList.remove(&#39;fixed&#39;);
            footer.classList.add(&#39;hidden&#39;);
            window.setTimeout(() =&gt; &#123;
                document.activeElement.scrollIntoViewIfNeeded();
            &#125;, 100);
        &#125; else &#123;
            document.activeElement.blur();
            footer.classList.add(&#39;fixed&#39;);
            footer.classList.remove(&#39;hidden&#39;);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><p>这个时候只需要把我上面代码中的addIosKeyboardHandler 方法在<code>componentDidMount</code>的时候，进行触发即可。</p>
<p>当然，这里可能要补充一个小知识点，由于<code>componentDidMount</code>的时候，通过<code>React</code>渲染的dom已经处于loaded的状态，因此无需再像以往通过<code>window.onload</code>或者jq的<code>$(document).ready</code>去添加事件处理程序。</p>
<h2 id="下面的问题"><a href="#下面的问题" class="headerlink" title="下面的问题"></a>下面的问题</h2><p>这样的方法可以解决大部分的问题。但是还是会有一些历史遗留代码与此方案相处地并不融洽。</p>
<p>比如在购物车页面，会有一个输入框，可以改变选定商品的数量。购物车的结算button是fixed的定位，当时考虑到在他下面还有导航栏，因此，提前计算好了导航栏的高度。于是这个部分的样式大概是这样的：</p>
<pre><code>  display: fixed;
  bottom: 1.4rem;
</code></pre>
<p>恩，我们使用了rem布局。结果就会造成由于我前面的处理，只会在出现虚拟键盘的时候将footer（底部导航栏）隐藏掉，并不会对结算button进行处理，因此，如果看Android上的表现，这个时候，这个button所在的部分就会和键盘之间有1.4rem的间距。而诡异的是，结算button部分还是处于fixed的状态，而这，并非我所期待的。</p>
<p>这就是另外一个问题了。</p>
<p>所以，还是说回来。这也是为什么之前看到其他一些人有一些友情提示：<strong>在做移动开发的时候，不要将input元素和其他fixed的元素放在一起</strong>。而像我这种更要命，我直接在页面底部放了两个fixed的元素。</p>
<p>我目前的措施是针对这种情况，单独处理。毕竟，这也只是特例。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/05/29/201805/react-practice-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/29/201805/react-practice-4/" class="post-title-link" itemprop="url">React开发实践--4嵌套路由的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-29 18:24:49" itemprop="dateCreated datePublished" datetime="2018-05-29T18:24:49+08:00">2018-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/05/29/201805/react-practice-4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/05/29/201805/react-practice-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://7ktu2f.com1.z0.glb.clouddn.com/react.png"></p>
<hr>
<p>嵌套路由的应用</p>
<p>我们知道React-router v4中，可以实现嵌套路由。有了这样一个机制，我们不必将所有的路由完全放到一个统一的位置进行管理，而可以根据情况去对路由进行拆分。坦白讲，我一直认为在一个地方统一管理，要比四散开来维护起来更加简单（可能有点像中央集权和诸侯国各自为政的感觉）。但是最近有个实际应用，让我发现，嵌套路由的价值还是很大的。只是以前我们一直没有合理使用。</p>
<h1 id="先说一下实际使用场景。"><a href="#先说一下实际使用场景。" class="headerlink" title="先说一下实际使用场景。"></a>先说一下实际使用场景。</h1><p>我做的电商应用中，有一个叫做“爱逛店”的功能。（由于该应用主打线上线下融合，线下发展其实更好），每次从首页点击“爱逛店”图标进入“爱逛店”的门店展示列表，由于展示门店列表的过程是：</p>
<p>获取当前用户地理位置坐标&#x3D;》后端根据地理位置远近排序&#x3D;》将排好序的门店列表给到前端&#x3D;》前端展示</p>
<p>造成展示门店列表的过程其实是相对比较慢的。为了能够有一个尽量好的体验，我们在展示门店列表前，会有一个loading的动画效果。而由于采用路由统一管理的机制，原来的门店列表的组件和门店详情的组件之间是并列关系，导致每次从某一个门店详情页面返回到门店列表页面，都会造成门店详情页面组件生命周期结束，门店列表页面进入下一个生命周期。进入下一个生命周期意味着什么呢？意味着它又需要重新走一遍上面的流程，尽管有了这个loading的动画效果，但是体验上还是会差很多。而且，更影响用户体验的是：这个loading效果本来是好意，能够让用户在等待期间看到些东西，但是由于浏览器的机制，这个时候，浏览器判定你初始页面高度只有100%（屏幕高度）这么高，则一旦门店列表列出来之后，浏览器不会再将页面滚动到上一次这个页面滚动到的位置了。这意味着，你从门店详情页面返回到门店列表页面，每次先看到loading效果，然后每次看到的都是最顶上的三五个门店，而不是你上次浏览到的门店，这体验，当然就更差了。</p>
<p>有什么解决办法吗？当然了。使用嵌套路由，上面的问题就都不是问题了啊。</p>
<p>首先明确我们的需求，由于我们的用户看到的门店列表是基于地理位置的，他的大致地理位置短时间内是不会改变的。（我指的是用户点进门店详情页面时在北京，点返回后就来到了上海），门店的数量短时间内也是几乎不会改变的。（我指的是用户点进门店详情页面时有100家门店，点返回后就有105家）。正是基于这样的一个判断，我们或者可以将这些门店的数据暂时存储起来。每次用的时候，直接取出来用就好了。那么这个时候问题来了，我们应该将这些门店的数据存储在哪里呢？浏览器的本地存储（localStorage，sessionStorage）? 又或者是代码里？</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>不绕圈子了。我的办法是不如增加一个”爱逛店”管理组件。采用嵌套路由的方式来实现，门店数据的存储。先在主路由配置处（我的项目是app.js）写上：</p>
<pre><code>        &lt;RouteWithLayout path=&quot;/stores&quot; hideFooter=&#123;false&#125; loader=&#123;() =&gt; import(&#39;./Store/Store&#39;)&#125; /&gt;
</code></pre>
<p>然后先看下面这段代码：</p>
<pre><code>        &lt;Store&gt;
                &lt;Switch&gt;
                    &lt;RouteWithLayout exact path=&#123;`$&#123;this.props.match.url&#125;`&#125; hideFooter=&#123;false&#125; loader=&#123;() =&gt; import(&#39;./StoreList&#39;)&#125; stores=&#123;this.state.data&#125; withLayout=&#123;false&#125; /&gt;
                    &lt;RouteWithLayout exact path=&#123;`$&#123;this.props.match.url&#125;/:storeId`&#125; hideFooter=&#123;false&#125; loader=&#123;() =&gt; import(&#39;./StoreDetail&#39;)&#125;  withLayout=&#123;false&#125; /&gt;
                &lt;/Switch&gt;
        &lt;/Store&gt;
</code></pre>
<p>从上面代码我们可以看出来，无论用户想要浏览某一个门店（StoreDetail），还是说想要浏览门店列表（StoreList），都需要先进入Store这个管理组件。我可以用这个管理组件来做什么呢？很简单，以前没有这个管理组件的时候，从<code>/stores</code>这个路由切换到<code>/stores:storeId</code>这个路由，第一个组件生命周期结束，第二个组件生命周期开始。而由于我把获取门店列表的方法写在了<code>StoreList</code>这个组件里，因此每次从门店详情页点返回都会重新去找门店列表。现在，我要做的是，把获取门店列表的方法提到上一层，提到Store这个组件当中。</p>
<p>这个时候，我们再来看看。如果<code>/stores</code>这个路由切换到<code>/stores:storeId</code>这个路由</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>Store</td>
<td>didupdate</td>
</tr>
<tr>
<td>StoreList</td>
<td>unmount</td>
</tr>
<tr>
<td>StoreDetail</td>
<td>didmount</td>
</tr>
</tbody></table>
<p>而如果<code>/stores:storeId</code>这个路由切换到<code>/stores</code>这个路由呢？</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>Store</td>
<td>didupdate</td>
</tr>
<tr>
<td>StoreList</td>
<td>didmount</td>
</tr>
<tr>
<td>StoreDetail</td>
<td>unmount</td>
</tr>
</tbody></table>
<p>没错，无论哪种场景，<code>Store</code>这个组件都只会update，而不会进入下一个生命周期。因为在一开始我就配置好了。</p>
<pre><code>        &lt;RouteWithLayout path=&quot;/stores&quot; hideFooter=&#123;false&#125; loader=&#123;() =&gt; import(&#39;./Store/Store&#39;)&#125; /&gt;
</code></pre>
<p>因为在<code>/stores</code>这个路由的模糊匹配下，我任意切换路由，都只会让Store这个组件更新，不会触发didmount，那么我干脆把获取门店列表的方法写到他的componentDidMount()之中不就好了么，然后门店列表作为一个state值存储在这个组件的状态里，之后每次切换路由都能够立刻获取门店列表，无需loading，浏览器也能够记住上次这个页面滚动到的位置，返回后，还是原来的位置。</p>
<p>那位又说了，可是我要是直接在浏览器上输入某个门店的url，直接访问某个门店。你是不是还要把这个门店列表也给我获取到呢？那是不是得不偿失，更加影响用户体验呢？说的很对，所以我的策略是，在获取门店列表的方法中进行判断，只有<code>exact match path=&quot;/stores&quot;</code>这个路由的时候，我才去从服务端获取门店列表。那位又说了，那你这时候如果，如果点击页面上的返回导航，你回到门店列表页，由于在<code>Store</code>组件<code>didmount</code>阶段你没有获取门店列表，这个时候肯定会出错啊。是的，那我就不返回门店列表呗。反正用户你也不是从门店列表进入的我某个门店页面的，我直接让你回我的APP 首页就好了嘛！</p>
<p>除了用户体验的提升外，另外的好处是：随着你项目的扩大，这个对路由的分拆也能够便于管理。毕竟如果你的主路由配置里有一两百行路由配置，看起来也会很不舒服，类似的哲学是从中央不直接管辖所有的地级市（中国有338个地级市）而将这些市根据地理位置，由省来管理。中央只管理省一级。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前面说的很具体，具体的东西好处是便于理解。坏处可能就是，不能做到举一反三。所以我这还是来总结一下。</p>
<p><strong>如果你有一个应用场景：数据不会频繁更新，数据的请求过程影响用户体验，你的用户需要频繁地从子路由到孙子路由或孙子路由到子路由之间来还切换。那么可以考虑在子路由组件中，进行嵌套路由的配置，将请求数据的方法写在子路由组件当中，这样一来，用户体验会有一个很好的提高。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/05/28/201805/react-practice-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/28/201805/react-practice-3/" class="post-title-link" itemprop="url">React开发实践--3对象引用的误区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-28 18:24:49" itemprop="dateCreated datePublished" datetime="2018-05-28T18:24:49+08:00">2018-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/05/28/201805/react-practice-3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/05/28/201805/react-practice-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://7ktu2f.com1.z0.glb.clouddn.com/react.png"></p>
<hr>
<p>一个电商应用，有他的一个基本的结构。为了简化我们的代码，我们每一个页面组件外面都会再套上一层<code>&lt;BaseLayout/&gt;</code> ,通过配置<code>&lt;BaseLayout/&gt;</code>，我们可以控制每一个页面是否需要使用公共页头(header),公共的底部导航(footer)。这当然也是一些很基础的功能了，在此不再赘述。</p>
<p>基于上面的需要，我们最初写了下面的代码</p>
<pre><code>        const RouteWithLayout = (&#123;loader = null, exportName = null, hideFooter = true, hideReturnTop = false, ...rest&#125;) =&gt; &#123;
                const loadableOpts = &#123;
                    loader,
                    loading: LoadingComponent
                &#125;;

                if (exportName) &#123;
                    loadableOpts.render = (loaded, props) =&gt; &#123; // eslint-disable-line  react/display-name
                        const Component = loaded[exportName];
                        return &lt;Component &#123;...props&#125; /&gt;;
                    &#125;;
                &#125;
                const LoadableComponent = Loadable(loadableOpts);
                return (
                    &lt;Route &#123;...rest&#125; render=&#123;matchProps =&gt; (
                        &lt;BaseLayout hideFooter=&#123;hideFooter&#125; hideReturnTop=&#123;hideReturnTop&#125; &#123;...matchProps&#125;&gt;
                            &lt;LoadableComponent &#123;...matchProps&#125; /&gt;
                        &lt;/BaseLayout&gt;
                        )&#125;
                    /&gt;
                );
        &#125;;
</code></pre>
<p>看了前面 part-1的同学可能知道，我们在项目中引入了<code>React-loadable</code>这个第三方库，上面的代码也是基于它的实现。乍一看，他似乎没有问题。接下来，我们只需要写这样的配置就ok了。</p>
<pre><code>        &lt;RouteWithLayout exact path=&quot;/shopping-cart&quot; hideFooter=&#123;false&#125; hideReturnTop=&#123;true&#125; loader=&#123;() =&gt; import(&#39;./ShoppingCart&#39;)&#125; /&gt;
</code></pre>
<p>但是，在2-实现一个类似客户端的商品轮播图阅览交互 里面，我也已经提到过，我在此处遇到了一个坑。这个坑，也正是与上面我展示的代码有关。</p>
<p>再来简单回顾一下，当路由从&#x2F;products&#x2F;:productId 到&#x2F;products&#x2F;:productId&#x2F;showpic，事实上，动态引入的组件还是那个<code>ProductDetail</code>组件。按照我们的期待，如果前后两次引入的是同一个组件，这个组件需要update，而不是重新mount。但是就如同我在《React开发实践–2》里面介绍的那样，当路由发生改变的时候，<code>&lt;/ProductDetail /&gt;</code>竟然进入了下一个生命周期。</p>
<p>究其原因，由于路由发生了改变，如果<code>RouteWithLayout</code>没有写其他的生命周期方法的话，那它必然会得到更新。那么我们来看看<code>RouteWithLayout</code>组件更新之后的影响。这时候我们发现<code>LoadableComponent</code>这个变量的引用实际上发生了变化。因此造成当render<code> &lt;LoadableComponent &#123;...matchProps&#125; /&gt;</code>时，需要到下一个生命周期重新render。</p>
<p>可是对象引用发生了变化这种事情，我们应该怎么理解呢？说起来，这其实考察的还是JavaScript的基础。让我们暂时忘掉React这个框架，只提JavaScript。来看看下面这几行代码</p>
<pre><code>let arr = []
for(let i=0;i&lt;2;i++) &#123;
    const foo=&#123;a:1&#125;;
    arr.push(foo)
&#125;

console.log(arr[0]===arr[1]);  //false
</code></pre>
<p>大概学过半年JavaScript的同学，也都能明白这里为什么arr[0]和arr[1]并不相等了。这里还是谈谈我对这件事情的理解：</p>
<p>对于for循环内部的每次执行，都是一个<code>block</code>，每一个 <code>block</code>之间都相互独立。所以，我们也可以将上面的代码进行拆解。</p>
<pre><code>let arr = []
 &#123;
    const foo=&#123;a:1&#125;;
    arr.push(foo)
&#125;
 &#123;
    const foo=&#123;a:1&#125;;
    arr.push(foo)
&#125;

console.log(arr[0]===arr[1]);  //false
</code></pre>
<p>这个时候，就更好理解了。对于每一个块里面的<code>i</code>变量来说，他只在当前块内有效，当前块执行完毕之后，他就会被<code>垃圾回收</code>，销毁掉了。因此当我们比较的时候，arr[0]和arr[1]之间就不相等了。</p>
<p>有同学可能会问了，你用的是ES6 的语法。ES5是这样的吗？of course！</p>
<pre><code>var arr = []
for(var i=0;i&lt;2;i++) &#123;
    var foo=&#123;a:1&#125;;
    arr.push(foo)
&#125;

console.log(arr[0]===arr[1]);  //false
console.log(i);
</code></pre>
<p>关于我的这个示例，ES5 和 ES6的结果并没有区别。如果硬要说有什么区别的话，那就是<code>i</code>这个变量是否在块级(block)之外继续有效。那相对于我本次讨论，实际上是另外一个话题了。</p>
<p>既然说到了这里，我们再想一想。怎么样才能让arr[0]与arr[1]相等呢？在<strong>JavaScript，只能是在比较的两者为同一引用的情况下，才能实现严格相等</strong>。所以按照这个思路，我们可以对上面的代码进行个改写。</p>
<pre><code>const foo=&#123;a:1&#125;;
let arr = []
for(let i=0;i&lt;2;i++) &#123;
    arr.push(foo)
&#125;

console.log(arr[0]===arr[1]);  //true
</code></pre>
<p>没错，就是把foo的生命提到for循环之外。这样的话，每次推入到arr这个数组中的值的引用就一定是相同的了。</p>
<p>这时候，让我们重新回到刚才遇到问题的React代码。<code>RouteWithLayout</code>当前是一个无状态组件，只要它的父组件发生了更新，它也会相应地发生更新。然后执行相应的代码。这其实就类似于我们上面提到的for循环结构。<strong>每一次<code>RouteWithLayout</code>执行的时候，都像是for循环在执行其中一个block</strong>，不难理解，每一次LoadableComponent的引用发生了变化。</p>
<p>所以，还是上面的思路，我们把<code>LoadableComponent</code>的声明放到<code>render()</code>方法之外，怎么做到呢？改写无状态组件为有状态组件。将这个对象声明以状态的方式存在于组件当中。这样就可以实现我们想要的效果，即如果动态加载的是同一个组件，则组件只会发生更新，而不会进入下一个生命周期。相应的代码在《React开发实践–2》中已经提到过了，再粘贴一遍。</p>
<pre><code>        `
        import React from &#39;react&#39;;
        import ReactDOM from &#39;react-dom&#39;;
        import PropTypes from &#39;prop-types&#39;;
        import &#123;BrowserRouter, Route, Switch, Redirect&#125; from &#39;react-router-dom&#39;;
        import BaseLayout from &#39;./BaseLayout&#39;;
        import Loading from &#39;react-loading&#39;;
        import Loadable from &#39;react-loadable&#39;;


        const LoadingComponent = props =&gt; &#123;
        // something 
        &#125;;


        class RouteWithLayout extends React.Component &#123;
            state = &#123;
                loader: () =&gt; &#123;&#125;,
                exportName: null,
                LoadableComponent: null
            &#125;

            static getDerivedStateFromProps(nextProps, prevState) &#123;
            
                if (nextProps.loader.toString() === prevState.loader.toString() &amp;&amp; nextProps.exportName === prevState.exportName) return null;
                const &#123; loader, exportName &#125; = nextProps;
                const loadableOpts = &#123;
                    loader,
                    loading: LoadingComponent
                &#125;;

                if (exportName) &#123;
                    loadableOpts.render = (loaded, props) =&gt; &#123;
                        const Component = loaded[exportName];
                        return &lt;Component &#123;...props&#125; /&gt;;
                    &#125;;
                &#125;
                return &#123;
                    loader,
                    exportName,
                    LoadableComponent: Loadable(loadableOpts)
                &#125;;
            &#125;

            render() &#123;
                const &#123; hideFooter, hideReturnTop, ...rest&#125; = this.props;
                return (
                    &lt;Route &#123;...rest&#125; render=&#123;matchProps =&gt; (
                        &lt;BaseLayout hideFooter=&#123;hideFooter&#125; hideReturnTop=&#123;hideReturnTop&#125; &#123;...matchProps&#125;&gt;
                            &lt;this.state.LoadableComponent &#123;...matchProps&#125; /&gt;
                        &lt;/BaseLayout&gt;
                        )&#125;
                    /&gt;
                );
            &#125;
        &#125;`
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hktkdy.com/2018/05/27/201805/react-practice-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhangolve">
      <meta itemprop="description" content="分享是一种快乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海阔天空的云">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/27/201805/react-practice-2/" class="post-title-link" itemprop="url">React开发实践--2实现一个类似客户端的商品轮播图阅览交互</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-27 18:24:49" itemprop="dateCreated datePublished" datetime="2018-05-27T18:24:49+08:00">2018-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:33:22" itemprop="dateModified" datetime="2023-04-28T14:33:22+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/05/27/201805/react-practice-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/05/27/201805/react-practice-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://7ktu2f.com1.z0.glb.clouddn.com/react.png"></p>
<hr>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇仍然并不会也不打算去介绍或者科普<code>React</code>框架的基本知识点，但是会在行文中有很多涉及。</p>
<h1 id="怎样实现的思路"><a href="#怎样实现的思路" class="headerlink" title="怎样实现的思路"></a>怎样实现的思路</h1><p>一个电商APP, 要想让他的web HTML5 体验更接近客户端本身还是有很大的挑战的。怎样做出一些更符合客户端用户操作习惯的交互来，是前端开发中很重要的一个点。</p>
<p>我想要做的是一个类似客户端的商品轮播图阅览交互，总体来说，他的主要逻辑是：</p>
<ol>
<li>在商品详情页显示商品轮播图</li>
<li>点击任意一张商品轮播图，能够全局浏览商品轮播图</li>
<li>通过左划右滑手势可是在全屏状态下阅览商品轮播图</li>
<li><strong>点击返回键，退出全屏，回到商品详情页</strong></li>
</ol>
<p>有赖于<code>react-photoswipe</code>　这个库的支持，它已经将前三项做得很好了。我希望做的其实是第四项。细化需求，它不仅仅要求能够回到商品详情页，还希望能够最大限度地优化性能，最好的体验就是像客户端那样。</p>
<p>这里，我采取的措施是，将我集成了<code>react-photoswipe</code>　这个库的组件放到&lt;&#x2F;ProductDetail &#x2F;&gt;　组件之中。           </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ProductCarousel images=&#123;product.images&#125; alt = &#123;product.name&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，我的想法是这样的：</p>
<blockquote>
<p>当用户在商品详情页点击任意一张商品轮播图时，页面上全屏显示那张商品轮播图，同时，当前的路由发生改变,由<code>/products/:productId</code> 到<code>/products/:productId/showpic</code>，这样，当用户点击返回的时候，就能够实现从当前路由<code>/products/:productId/showpic</code>返回到了<code>/products/:productId</code></p>
</blockquote>
<p>但是，这个时候，我遇到了很多与<code>React-router</code>有关的坑，其实与其说是坑，倒不如说是知识上的不足。当我把这些知识补足之后，再来看，其实并不难了。</p>
<h2 id="React-router"><a href="#React-router" class="headerlink" title="React-router"></a>React-router</h2><h3 id="第一个问题-exact"><a href="#第一个问题-exact" class="headerlink" title="第一个问题: exact"></a>第一个问题: exact</h3><p>很明显，第一个问题是关于<code>React-router</code> 在<code>app.js</code> 中的配置的。前面介绍了我的总体思路，这个思路的一个关键点是<strong>当路由发生改变的时候，<code>&lt;/ProductDetail /&gt;</code>组件不应该unmount 或者重新didmount</strong>， 这样才能够让这种轮播图阅览交互更像是客户端的体验。</p>
<p>这时候，用到的第一个知识点是<code>React-router</code>的exact 配置。这本身并不是什么难点，我在这里只是想说明它的这一妙用。</p>
<p>由于我们大部分的<code>React-router</code>的匹配都采用了exact的匹配，在这个时候，我把原来对商品详情页的exact匹配去掉了，使得能够实现前述我的思路。</p>
<h3 id="第二个问题-lt-ProductDetail-gt-组件的生命周期"><a href="#第二个问题-lt-ProductDetail-gt-组件的生命周期" class="headerlink" title="第二个问题: &lt;/ProductDetail /&gt;组件的生命周期"></a>第二个问题: <code>&lt;/ProductDetail /&gt;</code>组件的生命周期</h3><p>前面说了，我们在这个项目中，为了优化前端性能，使用了动态加载，来进行<code>split coding</code>。这个时候，我发现，如果使用了动态加载，我的<code>&lt;/ProductDetail /&gt;</code>组件每次进入轮播图全屏页面时，都会因为进入到了下一个生命周期，而不能进入轮播图全屏页。</p>
<p>这个问题出在哪里呢？原来这个问题是由于<code>React-router</code>以及它所关联的<code>React</code>生命周期造成的。</p>
<p>我以前有个误区，不知道各位读者是否也会存在这样的误区。就是React简单地认为它是单向数据流，除非父组件传递給子组件能够改变父组件本身的属性，否则，子组件的更新，不会引起父组件的更新甚至进入下一个生命周期。</p>
<p>但是，当然没有那么简单。</p>
<p>还是以我上面的问题为例，为什么会出现那样的问题呢？原因是：当一开始进入轮播图详情页面时，在我的<code>&lt;ProductCarousel /&gt;</code>这个子组件发生了变化，他引起了路由的变化。由于我的路由管理由<code>React-router</code>完成，实际上顶部的<code>&lt;Switch&gt;</code>也相应地发生了更新，甚至可以这么说，<code> &lt;Switch&gt;</code>组件也必须发生更新，只有这样，他才有存在的意义。而紧接着，由于我们对动态引入的错误使用，造成了<code>&lt;/ProductDetail /&gt;</code>组件被迫重新装载，而他的重新装载又直接造成了他进入下一个生命周期。</p>
<p>关于我们是怎样错误使用动态引入的，以后会详细来解释。</p>
<p>这里，还是针对我刚刚提到的误区来谈一谈。所以，还是说回来，这当然不能算是坑，这是对知识理解的不深刻。</p>
<p>看到这个问题之后，我最初想到的是: <strong>如果路由改变了，而加载的组件（import）并没有改变，就不更新这个组件的状态</strong></p>
<p>但是，马上就发现了问题，还是这个例子：路由从<code>/products/:productId</code> 到<code>/products/:productId/showpic</code>发生了改变，这个时候我们没有改变<code>&lt;/ProductDetail /&gt;</code>组件的状态，则他的属性（location,props）较之前并没有发生改变。这本身就不是正常的，也就会从根本上造成虽然一个问题解决了，但是总还有新的问题产生。为什么呢？因为你没有按照规律办事啊！</p>
<p><code>React-router</code>的思想是什么呢？其中一个思想就是组件上的React-router赋予的属性（location,history )是与实际相一致的。但是刚才，我试图通过调用 <code>componentWillReceiveProps</code>方法，来实现阻止组件更新的目的。</p>
<p>结果造成什么问题了呢？</p>
<p>一开始，我点击轮播图，路由切换，打开轮播图，没有问题。可是当我点击返回键的时候，由于我前面的判断：<strong>如果路由改变了，而加载的组件（import）并没有改变，就不更新这个组件的状态</strong>，导致没有退回到商品详情浏览页。这当然是不正常的了。</p>
<p>我们应该顺应<code>React-router</code>的设计思想，最后采取的办法是：<strong>如果路由改变了，而加载的组件（import）并没有改变，这个装载的组件不变，但他的属性(location,history)要相应地发生改变，他必须仍然在原有的生命周期中</strong></p>
<p>可能听起来，还是有点抽象，还是直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import PropTypes from &#x27;prop-types&#x27;;</span><br><span class="line">import &#123;BrowserRouter, Route, Switch, Redirect&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import BaseLayout from &#x27;./BaseLayout&#x27;;</span><br><span class="line">import Loading from &#x27;react-loading&#x27;;</span><br><span class="line">import Loadable from &#x27;react-loadable&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const LoadingComponent = props =&gt; &#123;</span><br><span class="line">// something </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RouteWithLayout extends React.Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        loader: () =&gt; &#123;&#125;,</span><br><span class="line">        exportName: null,</span><br><span class="line">        LoadableComponent: null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">       </span><br><span class="line">        if (nextProps.loader.toString() === prevState.loader.toString() &amp;&amp; nextProps.exportName === prevState.exportName) return null;</span><br><span class="line">        const &#123; loader, exportName &#125; = nextProps;</span><br><span class="line">        const loadableOpts = &#123;</span><br><span class="line">            loader,</span><br><span class="line">            loading: LoadingComponent</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (exportName) &#123;</span><br><span class="line">            loadableOpts.render = (loaded, props) =&gt; &#123;</span><br><span class="line">                const Component = loaded[exportName];</span><br><span class="line">                return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            loader,</span><br><span class="line">            exportName,</span><br><span class="line">            LoadableComponent: Loadable(loadableOpts)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; hideFooter, hideReturnTop, ...rest&#125; = this.props;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Route &#123;...rest&#125; render=&#123;matchProps =&gt; (</span><br><span class="line">                &lt;BaseLayout hideFooter=&#123;hideFooter&#125; hideReturnTop=&#123;hideReturnTop&#125; &#123;...matchProps&#125;&gt;</span><br><span class="line">                    &lt;this.state.LoadableComponent &#123;...matchProps&#125; /&gt;</span><br><span class="line">                &lt;/BaseLayout&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="第三个问题-匹配不匹配"><a href="#第三个问题-匹配不匹配" class="headerlink" title="第三个问题: 匹配不匹配"></a>第三个问题: 匹配不匹配</h3><p>我们知道，在客户端的图片阅览里，实际上，是不能直接通过访问地址的方式，来全屏浏览商品轮播图的，这是一个更深层次的交互设计，因此我在<code>&lt;/ProductDetail /&gt;</code>组件的<code>componentDidMount</code> 方法中写下了这样的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!this.props.match.isExact) &#123;</span><br><span class="line">    this.props.history.replace(this.props.match.url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此依赖，当初次载入<code>&lt;/ProductDetail /&gt;</code>组件时，一律显示商品详情页面。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最终的实现效果，前面提到的指标都已经完成了。也能够比较完美地使用动态加载来加载组件了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhangolve</p>
  <div class="site-description" itemprop="description">分享是一种快乐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">328</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhangolve</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'HfDBPvTz5vS7thoY9gHJFRYV-gzGzoHsz',
      appKey     : 'WmbqlggY1zbg57bzcbjuYA8n',
      placeholder: "anything",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
